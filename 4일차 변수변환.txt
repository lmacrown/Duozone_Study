literal : 상수
4진수 : 0b로 시작
8진수 : 0으로 시작
16진수 : 0x로 시작
뒤에 L이 붙으면 long타입임을 알려줌
자동타입 변환 : 큰값에 작은 값을 넣으면 타입을 바꿔줌
강제타입 변환 : 작은 값에 큰값을 넣으면 오류가 뜨므로 타입을 강제로 바꿔줌(int)
byte로 지정시 내부적으로 값을 -127~128로 인식하여
byte x,y=0;
byte r=x+y;가 오류가 뜸(2byte를 사용한다고 인식) => byte r=(byte) (x+y);
string타입에서 숫자를 그냥 쓰면(3) 문자로 변환해줌// String str = 3+'7';//37
String str = 1+3+'7';//47
String str ='3'+7+5//375
parse* : 해당 타입으로 변경
{}를 벗어나면 쓸질 못함(지역 변수)

printf : 출력시 해당 값을 직접 입력 가능 // printf(" 나이 : %d ", 25);
System.out.printf("a=[%6d]",a); // a=[____10];
System.out.printf("a=[%-6d]",a); // a=[10____];
System.out.printf("a=[%06d]",a); // a=[000010];
System.out.printf("f=[%f]",123.456); // f=[123.456]
System.out.printf("f=[%10.2f]",123.456); // f=[___123.46];=>반올림
- : 뒤로 공백이 생김. / 0 : 0이 앞에서 생김

\t : 공백이 8개가 생김
nextLint() : 엔터키까지 입력을 받음
문자열 비교시 equals를 사용
프로그램 실행시 <파일명>으로 실행가능
char은 완전 비어있으면 정의 안됨

byte b =10;
byte result =-b;//컴파일 에러  2바이트로 인식
후위형 : a++(계산이 끝나고 1을 더함)
전위형 : ++a(1을 더하고 계산을 함)
전위연산자가 후위연산자보다 좋을 수 있음
오버플로우/언더플로우 : 값이 초과되서 맨처음값 또는 맨뒷값이 됨
소수로 계산기 계산이 정확하지 않게 될 수 있으므로 정수로 계산할것
NaN : 숫자가 아님
and, or , xor, not은 새로운 값이 아닌 해당 튜플 값임 
xor 은 결과값에다가 다시 ^을 하면 원본값이 나옴=>암호화에 사용가능
쉬프트 연산자 : <<  이동한 숫자만큼 2를 곱함. >> 이동한 숫자만큼 2를 나눔
1<<2  :  4
수(작은수)는 메모리주소가 작은곳부터 들어감
메모리에 저장되는 수 : 부호+지수부+가수부
초기화 : 변수를 선언함과 동시에 값을 설정하는 것
Math.random() =0.0~1.0까지의 수중 랜덤으로 생성
색인 배열 : index
연관 배열 : map