스레드 : 4G할당. 메소드, 힙 , 스택으로 구성. 스택이 T1, T2(역할 수 만큼)로 나누어짐. 스택만 자기 데이터
final : 변수 또는 생성된 객체만 고정
스레드 동기화 : 작업을 할 때 동안 다른 스레드는 접근하지 못하게 함
동기화는 안 할수록 좋음=>메모리를 공유하여 씀
1) 동기화(synchronized) 메소드를 호출
2) 동기화 블록 호출
동기화가 될려면 object로부터 상속돼야함
동기화를 할려면 두 객체 모두 synchronized를 선언해야함

스레드 제어 : 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고 자신은 일시정지 상태로 만듬
=> 핵심은 공유 객체
wait() : 모든 스레드가 실행을 일시중지 시킴
notify()/notifyAll() : 일시정지 된 스레드를 한개/전체 깨울수 있음
=>동기화 메소드 또는 동기화 블록 내에서만 사용할수 있음(synchronized)

스레드 안전 종료 : 스레드를 강제 종료시키기 위해 stop()메소드가 있으나 강제종료로 인하여 오류 발생
=>리소스 정리후 run()메소드를 빨리 종료
1) 조건 이용
2) interrupt(); : 일시정지 상태에 있을 때 사용

데몬 스레드 : 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드.
주 스레드가 종료되면 데몬 스레드도 따라서 자동으로 종료
=>종료작업에 대한 처리를 꼭 해줘야함

스레드 풀 : 병렬 작업 증가로 인한 스레드의 폭증을 막음.
작업처리에 사용되는 스레드를 제한된 개수만큼 정해 놓음
java.util.concureent 패키지의 ExecutorService인터페이스와 Executors클래스를 사용
- newCachedThreadPool() : 생성가능한 스레드 수 제한이 없음
- newFixedThreadPool(int THreads) : 생성된 코어수만큼만 사용하며 정해진 수 만큼 스레드 생성가능
60초동안 스레드가 아무 작업을 하지 않으면 스레드를 풀에서 제거

스레드 풀 종료
- shutdown() : 현재 처리 중인 작업과 작업 큐에 대기하고 있는 모든 작업을 처리한 뒤 종료
- shutdownNow() : 현재 작업처리 중인 스레드를 interrupt하여 작업 중지 시키고 스레드 풀을 종료

작업 생성과 처리 요청
- Runnable : 리턴값이 없음. 타입은 void
- Callable : 리턴값이 있음. 타입은 Future
=>ExecutorService : 처리할 스레드를 확인하고 없으면 스레드 생성. 최대 5개 스레드 생성