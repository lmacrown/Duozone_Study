상속 : 부모클래스(데이터,메소드)가 자식클래스에게 물려주는 것. 재사용과 중복코드절감
수정을 최소화 할 수 있음, 다중상속 불가능
상속받은 클래스를 실행할 때 부모클래스가 실행되고 자식클래스가 생성됨
생성자가 없으면 컴파일러가 기본생성자(인자가 없는)를 생성함
부모클래스에서 기본 생성자가 없으면 자식 생성자 선언에서 컴파일 에러가 일어남
super() : 1) 자식에서 부모의 생성자 함수를 호출(super(인자)) 
2) 일반 메서드에서 부모객체를 이용해서 부모 멤버를 접근할때(super.메소드+(인자))
this : 1) 생성자 함수에서 다른 생성자 함수 호출(this(인자) 2) 일반 메서드에서는 객체 의미(this.메소드)
!!오버라이딩 : 상속된 메소드를 자식클래스에서 재정의 하는것. !부모 메서드는 숨겨지고 자식 메소드가 우선적 사용
오버라이딩 주의점  
1) 부모 메서드의 선언부(리턴 타입, 메소드 이름, 매개변수)와 동일 
2) 접근 제한을 더 강하게 오버라이딩 불가(public->private)
3) 새로운 예외를 throws할수 없다
@override : 자식클래스에서 오버라이딩함을 알리며 필수는 아니지만 쓰는 코딩이 좋음

상속 : 1. 재사용 2. 재정의(자식클래스에서)=>특별화
상속 불가 : 1) 클래스 앞에 final을 사용 2) 메소드 앞에 final을 사용
hook : 중간에 가로챔(재정의)
Computer computer = new MyComputer(); =>제어권이 MyComputer로 넘어감
public : 메소드, private : 필드, default : 패키지 protected : 상속관계
protected : 특별한 경우에만 사용. 부모코딩이 다 보임. 좋은 코딩은 아님

인스턴스 : 객체
!!!obj1 instanceof B : A의 참조변수를 B객체로 만들수 있냐를 물어봄 
A obj1 = new B; // A 객체만 접근하나 B 함수는 접근가능
obj1.b=100;
obj1.a=10;
obj1.print(); => 100 //B에게 제어권이 넘어가서 B의 값이 출력됨(후크)
=>다형성(가상함수)

1) SPR : 단일 책임 원칙. 한 클래스는 하나의 책임만 가짐
2) OCP : 개발-폐쇄 원칙. 확장에는 열려있으나 변경에는 닫혀 있어야 함. 다형성을 잘 활용
3) LSP : 리스코프 치환 원칙. 프로그램의 정확성을 깨면 안됨
4) ISP : 인터페이스 분리 원칙. 여러 개의 인터페이스가 하나의 인터페이스보다 낫다
5) DIP : 의존관계 역전 원칙. 구체화에 의존하지 않고 추상화에 의존해야 한다.
코딩은 하나만 있어야한다. 중복코드 배제
탬플릿 : 일반화, 특정 타입에 종속되지않고 프로그램을 만드는 것
< > : 데이터타입이 들어옴
abstract class : 참조변수로만 사용가능
interface(약속) : 추상 메서드로만 구성, 교체가능. 변수를 선언하면 상수가 됨
(public) 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드/ (private)메소드, 정적 메서드
호출시 구현자에게 제어권이 넘어감
sealed~permits  : 무분별한 자식클래스 생성을 방지하는 클래스 